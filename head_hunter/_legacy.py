"""Functionality for maintaining compatibility with 1.20.4- datapacks"""

import re
from typing import Iterable, NamedTuple

_FORMATTING_CODES = (
    ("§0", "black"),
    ("§1", "dark_blue"),
    ("§2", "dark_green"),
    ("§3", "dark_aqua"),
    ("§4", "dark_red"),
    ("§5", "dark_purple"),
    ("§6", "gold"),
    ("§7", "gray"),
    ("§8", "dark_gray"),
    ("§9", "blue"),
    ("§a", "green"),
    ("§b", "aqua"),
    ("§c", "red"),
    ("§d", "light_purple"),
    ("§e", "yellow"),
    ("§f", "white"),
    ("§k", "obfuscated"),
    ("§l", "bold"),
    ("§m", "strikethrough"),
    ("§n", "underlined"),
    ("§o", "italic"),
    ("§r", "reset"),
)


class LegacyHeadSpec(NamedTuple):
    """Original specification of a player head

    Attributes
    ----------
    name : str
        The display name of the head, including any formatting characters
    skull_owner : str
        The skull owner specification (which can be tied to a specific texture)
    spec : str
        The full head spec such that calling
        ```
        /give @s minecraft:player_head{spec}
        ```
        will give you that head
    comment : str or None
        An optional annotation on the head spec (that will only be used
        internally) for referencing, for example, a particular head variant
    """

    name: str
    skull_owner: str

    @property
    def spec(self):
        return r'display:{Name:"{\"text\":\"' + self.name + r'\"}"},' + self.skull_owner

    comment: str | None = None

    @classmethod
    def from_username(cls, name: str) -> "LegacyHeadSpec":
        """Construct a HeadSpec from a player's name alone (this will yield
        the head from the player's current skin)

        Parameters
        ----------
        name : str
            The player's username

        Returns
        -------
        LegacyHeadSpec
            The corresponding head spec
        """
        return cls(name, f"SkullOwner:{name}")

    def __str__(self):
        return self.spec

    def __repr__(self):
        sans_formatting = re.sub(r'\\?"|\xA7.|}', "", self.name)
        representation = f"HeadSpec({sans_formatting}"
        if self.comment:
            representation += f",comment={self.comment}"
        return representation + ")"


def loads(headlist: str | bytes) -> list[LegacyHeadSpec]:
    """Deserialize a list of HeadSpecs written by `dumps()`

    Parameters
    ----------
    headlist : str
        The serialized head specs, consisting of a series of 1-3-line sections,
        delimited by blank lines, as generated by `dumps()`

    Returns
    -------
    list of HeadSpec
        The deserialized head specs
    """
    if isinstance(headlist, bytes):
        headlist = headlist.decode("utf-8")
    heads: list[LegacyHeadSpec] = []
    for head in headlist.split("\n\n"):
        lines = head.splitlines()
        if len(lines) == 1:
            heads.append(LegacyHeadSpec.from_username(lines[0]))
        elif len(lines) == 2:
            heads.append(LegacyHeadSpec(*lines))
        else:
            heads.append(LegacyHeadSpec(lines[1], lines[2], comment=lines[0]))
    return heads
