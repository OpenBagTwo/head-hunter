"""Functionality for maintaining compatibility with 1.20.4- datapacks"""

import re
from typing import Iterable, NamedTuple

_FORMATTING_CODES = (
    ("§0", "c*black"),
    ("§1", "c*dark_blue"),
    ("§2", "c*dark_green"),
    ("§3", "c*dark_aqua"),
    ("§4", "c*dark_red"),
    ("§5", "c*dark_purple"),
    ("§6", "c*gold"),
    ("§7", "c*gray"),
    ("§8", "c*dark_gray"),
    ("§9", "c*blue"),
    ("§a", "c*green"),
    ("§b", "c*aqua"),
    ("§c", "c*red"),
    ("§d", "c*light_purple"),
    ("§e", "c*yellow"),
    ("§f", "c*white"),
    ("§k", "obfuscated"),
    ("§l", "bold"),
    ("§m", "strikethrough"),
    ("§n", "underlined"),
    ("§o", "italic"),
    ("§r", "reset"),
)


class LegacyHeadSpec(NamedTuple):
    """Original specification of a player head

    Attributes
    ----------
    name : str
        The display name of the head, including any formatting characters
    skull_owner : str
        The skull owner specification (which can be tied to a specific texture)
    spec : str
        The full head spec such that calling
        ```
        /give @s minecraft:player_head{spec}
        ```
        will give you that head
    comment : str or None
        An optional annotation on the head spec (that will only be used
        internally) for referencing, for example, a particular head variant
    """

    name: str
    skull_owner: str

    @property
    def spec(self):
        return r'display:{Name:"{\"text\":\"' + self.name + r'\"}"},' + self.skull_owner

    comment: str | None = None

    @classmethod
    def from_username(cls, name: str) -> "LegacyHeadSpec":
        """Construct a HeadSpec from a player's name alone (this will yield
        the head from the player's current skin)

        Parameters
        ----------
        name : str
            The player's username

        Returns
        -------
        LegacyHeadSpec
            The corresponding head spec
        """
        return cls(name, f"SkullOwner:{name}")

    def __str__(self):
        return self.spec

    def __repr__(self):
        sans_formatting = re.sub(r'\\?"|\xA7.|}', "", self.name)
        representation = f"HeadSpec({sans_formatting}"
        if self.comment:
            representation += f",comment={self.comment}"
        return representation + ")"


def loads(headlist: str | bytes) -> list[LegacyHeadSpec]:
    """Deserialize a list of HeadSpecs written by `dumps()`

    Parameters
    ----------
    headlist : str
        The serialized head specs, consisting of a series of 1-3-line sections,
        delimited by blank lines, as generated by `dumps()`

    Returns
    -------
    list of HeadSpec
        The deserialized head specs
    """
    if isinstance(headlist, bytes):
        headlist = headlist.decode("utf-8")
    heads: list[LegacyHeadSpec] = []
    for head in headlist.split("\n\n"):
        lines = head.splitlines()
        if len(lines) == 1:
            heads.append(LegacyHeadSpec.from_username(lines[0]))
        elif len(lines) == 2:
            heads.append(LegacyHeadSpec(*lines))
        else:
            heads.append(LegacyHeadSpec(lines[1], lines[2], comment=lines[0]))
    return heads


def convert_format_codes_to_format_flags(name_str: str) -> dict[str, str | bool]:
    """Given a string containing formatting codes
    (see: https://minecraft.wiki/w/Formatting_codes), output the corresponding
    formatting flags

    Parameters
    ----------
    name_str : str
        A string containing formatting codes (any other characters will
        be ignored)

    Returns
    -------
    dict
        The recognized formatting codes
    """
    lookup = dict(_FORMATTING_CODES)
    flags: dict[str, str | bool] = {}
    for modifier in (name_str[i : i + 2] for i in range(len(name_str) - 1)):
        try:
            flag = lookup[modifier]
        except KeyError:
            continue  # probably means the string is invalid. # TODO: maybe warn?
        if flag[:2] == "c*":
            flags["color"] = flag[2:]
        elif flag == "reset":
            if not flags:  # this is expected
                continue
            # TODO: warn that this is probably not going to behave right?
        else:
            flags[flag] = True
    return flags
