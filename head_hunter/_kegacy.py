"""Functionality for maintaining compatibility with 1.20.4- datapacks"""

import re
from typing import Iterable, NamedTuple


class LegacyHeadSpec(NamedTuple):
    """Original specification of a player head

    Attributes
    ----------
    name : str
        The display name of the head, including any formatting characters
    skull_owner : str
        The skull owner specification (which can be tied to a specific texture)
    spec : str
        The full head spec such that calling
        ```
        /give @s minecraft:player_head{spec}
        ```
        will give you that head
    comment : str or None
        An optional annotation on the head spec (that will only be used
        internally) for referencing, for example, a particular head variant
    """

    name: str
    skull_owner: str

    @property
    def spec(self):
        return r'display:{Name:"{\"text\":\"' + self.name + r'\"}"},' + self.skull_owner

    comment: str | None = None

    @classmethod
    def from_username(cls, name: str) -> "LegacyHeadSpec":
        """Construct a HeadSpec from a player's name alone (this will yield
        the head from the player's current skin)

        Parameters
        ----------
        name : str
            The player's username

        Returns
        -------
        LegacyHeadSpec
            The corresponding head spec
        """
        return cls(name, f"SkullOwner:{name}")

    def __str__(self):
        return self.spec

    def __repr__(self):
        sans_formatting = re.sub(r'\\?"|\xA7.|}', "", self.name)
        representation = f"HeadSpec({sans_formatting}"
        if self.comment:
            representation += f",comment={self.comment}"
        return representation + ")"

    def dumps(self) -> str:
        """Reference serialization method. Feel free to write your own.

        Returns
        -------
        str
            1-3 lines specifying the head spec in a concise and standard format
        """
        if self.comment is None:
            header = repr(self)[len("HeadSpec(") : -1]
        else:
            header = self.comment
        writeme = [header, self.name, self.skull_owner]
        if header == self.name:
            del writeme[1]
            if header == self.skull_owner:
                del writeme[1]
        return "\n".join(writeme)


def dumps(heads: Iterable[LegacyHeadSpec]) -> str:
    """Serialize a list of HeadSpecs so they can be written to file

    Parameters
    ----------
    heads : list of LegacyHeadSpec
        The heads to serialize

    Returns
    -------
    str
        A series of 1-3-line sections, separated by blank lines, that specify
        each head in a concise and standard format
    """
    return "\n\n".join([head.dumps() for head in heads])


def loads(headlist: str | bytes) -> list[LegacyHeadSpec]:
    """Deserialize a list of HeadSpecs written by `dumps()`

    Parameters
    ----------
    headlist : str
        The serialized head specs, consisting of a series of 1-3-line sections,
        delimited by blank lines, as generated by `dumps()`

    Returns
    -------
    list of HeadSpec
        The deserialized head specs
    """
    if isinstance(headlist, bytes):
        headlist = headlist.decode("utf-8")
    heads: list[LegacyHeadSpec] = []
    for head in headlist.split("\n\n"):
        lines = head.splitlines()
        if len(lines) == 1:
            heads.append(LegacyHeadSpec.from_username(lines[0]))
        elif len(lines) == 2:
            heads.append(LegacyHeadSpec(*lines))
        else:
            heads.append(LegacyHeadSpec(lines[1], lines[2], comment=lines[0]))
    return heads
